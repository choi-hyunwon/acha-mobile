class rSlider {
  constructor(conf) {
    this.input = null;
    this.inputDisplay = null;
    this.slider = null;
    this.sliderWidth = 0;
    this.sliderLeft = 0;
    this.pointerWidth = 0;
    this.pointerR = null;
    this.pointerL = null;
    this.activePointer = null;
    this.selected = null;
    this.scale = null;
    this.step = 0;
    this.tipL = null;
    this.tipR = null;
    this.timeout = null;
    this.valRange = false;
    this.values = { start: null, end: null };
    this.conf = {
      target: null,
      values: null,
      set: null,
      range: false,
      width: null,
      scale: true,
      labels: true,
      tooltip: true,
      step: null,
      disabled: false,
      onChange: null,
      ...conf,
    };
    this.cls = {
      container: "rs-container",
      background: "rs-bg",
      selected: "rs-selected",
      pointer: "rs-pointer",
      scale: "rs-scale",
      noscale: "rs-noscale",
      tip: "rs-tooltip",
    };
    this.init();
  }

  init() {
    if (typeof this.conf.target === "object") {
      this.input = this.conf.target;
    } else {
      this.input = document.getElementById(this.conf.target.replace("#", ""));
    }
    if (!this.input) {
      console.error("Cannot find target element...");
      return;
    }
    this.inputDisplay = getComputedStyle(this.input).display;
    this.input.style.display = "none";
    this.valRange = !(this.conf.values instanceof Array);
    if (this.valRange) {
      if (
        !this.conf.values.hasOwnProperty("min") ||
        !this.conf.values.hasOwnProperty("max")
      ) {
        console.error("Missing min or max value...");
        return;
      }
    }
    this.createSlider();
    this.onResize.bind(this);
  }

  createSlider() {
    this.slider = this.createElement("div", this.cls.container);
    this.slider.innerHTML = '<div class="rs-bg"></div>';
    this.selected = this.createElement("div", this.cls.selected);
    this.pointerL = this.createElement("div", this.cls.pointer, [
      "dir",
      "left",
    ]);
    this.scale = this.createElement("div", this.cls.scale);
    if (this.conf.tooltip) {
      this.tipL = this.createElement("div", this.cls.tip);
      this.tipR = this.createElement("div", this.cls.tip);
      this.pointerL.appendChild(this.tipL);
    }
    this.slider.appendChild(this.selected);
    this.slider.appendChild(this.scale);
    this.slider.appendChild(this.pointerL);
    if (this.conf.range) {
      this.pointerR = this.createElement("div", this.cls.pointer, [
        "dir",
        "right",
      ]);
      if (this.conf.tooltip) {
        this.pointerR.appendChild(this.tipR);
      }
      this.slider.appendChild(this.pointerR);
    }
    this.input.parentNode.insertBefore(this.slider, this.input.nextSibling);
    if (this.conf.width) {
      this.slider.style.width = parseInt(this.conf.width) + "%";
    }
    this.sliderLeft = this.slider.getBoundingClientRect().left;
    this.sliderWidth = this.slider.clientWidth;
    this.pointerWidth = this.pointerL.clientWidth;
    if (!this.conf.scale) {
      this.slider.classList.add(this.cls.noscale);
    }
    this.setInitialValues();
  }

  setInitialValues() {
    this.disabled(this.conf.disabled);
    if (this.valRange) {
      this.conf.values = this.generateValues();
    }
    this.values.start = 0;
    this.values.end = this.conf.range ? this.conf.values.length - 1 : 0;
    if (this.conf.set && this.conf.set.length && this.validateSetValues()) {
      const [start, end] = this.conf.set;
      this.conf.range
        ? ((this.values.start = this.conf.values.indexOf(start)),
          (this.values.end = end ? this.conf.values.indexOf(end) : null))
        : (this.values.end = this.conf.values.indexOf(start));
    }
    this.createScale();
  }

  createScale() {
    this.step = this.sliderWidth / (this.conf.values.length - 1);
    for (let i = 0; i < this.conf.values.length; i++) {
      const span = this.createElement("span");
      const ins = this.createElement("ins");
      span.appendChild(ins);
      this.scale.appendChild(span);
      span.style.width =
        i === this.conf.values.length - 1 ? 0 : `${this.step - 2.5}px`;
      if (this.conf.labels) {
        ins.innerHTML = this.conf.values[i];
        ins.style.marginLeft = `${(ins.clientWidth / 2) * -1}px`;
      } else if (i === 0 || i === this.conf.values.length - 1) {
        ins.innerHTML = this.conf.values[i];
        ins.style.marginLeft = `${(ins.clientWidth / 2) * -1}px`;
      }
    }
    this.addEvents();
  }

  updateScale() {
    this.step = this.sliderWidth / (this.conf.values.length - 1);
    const spans = this.slider.querySelectorAll("span");
    spans.forEach((span) => (span.style.width = `${this.step}px`));
    // slider 마지막 span 태그의 width가 무조건 0이 되도록 설정 (임시)
    spans[spans.length - 1].style.width = 0;
    this.setValues();
  }

  addEvents() {
    const pointers = this.slider.querySelectorAll(`.${this.cls.pointer}`);
    const scaleSpans = this.slider.querySelectorAll("span");
    document.addEventListener("mousemove", this.move.bind(this));
    document.addEventListener("touchmove", this.move.bind(this));
    document.addEventListener("mouseup", this.drop.bind(this));
    document.addEventListener("touchend", this.drop.bind(this));
    document.addEventListener("touchcancel", this.drop.bind(this));
    pointers.forEach((pointer) =>
      pointer.addEventListener("mousedown", this.drag.bind(this))
    );
    pointers.forEach((pointer) =>
      pointer.addEventListener("touchstart", this.drag.bind(this))
    );
    scaleSpans.forEach((span) =>
      span.addEventListener("click", this.onClickPiece.bind(this))
    );
    window.addEventListener("resize", this.onResize.bind(this));
    this.setValues();
  }

  drag(event) {
    event.preventDefault();
    if (!this.conf.disabled) {
      const dir = event.target.getAttribute("data-dir");
      this.activePointer = dir === "left" ? this.pointerL : this.pointerR;
      this.slider.classList.add("sliding");
    }
  }

  move(event) {
    if (this.activePointer && !this.conf.disabled) {
      let posX =
        (event.type.includes("touch")
          ? event.touches[0].clientX
          : event.pageX) -
        this.sliderLeft -
        this.pointerWidth / 2;
      posX = Math.round(posX / this.step);
      posX = Math.max(0, Math.min(posX, this.conf.values.length - 1));

      if (this.conf.range) {
        if (this.activePointer === this.pointerL) {
          posX = Math.min(posX, this.values.end - 1);
          this.values.start = posX;
        } else {
          posX = Math.max(posX, this.values.start + 1);
          this.values.end = posX;
        }
      } else {
        this.values.end = posX;
      }
      this.setValues();
    }
  }

  drop() {
    this.activePointer = null;
  }

  setValues(t, i) {
    const e = this.conf.range ? "start" : "end";
    if (t && this.conf.values.includes(t))
      this.values[e] = this.conf.values.indexOf(t);
    if (i && this.conf.values.includes(i))
      this.values.end = this.conf.values.indexOf(i);

    if (this.conf.range && this.values.start >= this.values.end) {
      this.values.start = this.values.end - 1;
    }

    this.pointerL.style.left = `${
      this.values[e] * this.step - this.pointerWidth / 2
    }px`;
    if (this.conf.range) {
      if (this.conf.tooltip) {
        this.tipL.innerHTML = this.conf.values[this.values.start];
        this.tipR.innerHTML = this.conf.values[this.values.end];
      }
      this.input.value = `${this.conf.values[this.values.start]},${
        this.conf.values[this.values.end]
      }`;
      this.pointerR.style.left = `${
        this.values.end * `${this.step - 2.5}` - this.pointerWidth / 2
      }px`;
    } else {
      if (this.conf.tooltip)
        this.tipL.innerHTML = this.conf.values[this.values.end];
      this.input.value = this.conf.values[this.values.end];
    }
    this.values.end = Math.min(this.values.end, this.conf.values.length - 1);
    this.values.start = Math.max(this.values.start, 0);
    this.selected.style.width = `${
      (this.values.end - this.values.start) * this.step
    }px`;
    this.selected.style.left = `${this.values.start * this.step }px`;
    this.onChange();
  }

  onClickPiece(event) {
    if (!this.conf.disabled) {
      let posX = Math.round((event.clientX - this.sliderLeft) / this.step);
      posX = Math.max(0, Math.min(posX, this.conf.values.length - 1));
      if (
        this.conf.range &&
        posX - this.values.start <= this.values.end - posX
      ) {
        this.values.start = posX;
      } else {
        this.values.end = posX;
      }
      this.setValues();
    }
  }

  onChange() {
    clearTimeout(this.timeout);
    this.timeout = setTimeout(() => {
      if (typeof this.conf.onChange === "function")
        this.conf.onChange(this.input.value);
    }, 500);
  }

  onResize() {
    this.sliderLeft = this.slider.getBoundingClientRect().left;
    this.sliderWidth = this.slider.clientWidth;
    this.updateScale();
  }

  disabled(status) {
    this.conf.disabled = status;
    this.slider.classList.toggle("disabled", status);
  }

  createElement(tag, className, dataAttr) {
    const elem = document.createElement(tag);
    if (className) elem.className = className;
    if (dataAttr) elem.setAttribute(`data-${dataAttr[0]}`, dataAttr[1]);
    return elem;
  }

  generateValues() {
    const values = [];
    for (
      let i = this.conf.values.min;
      i <= this.conf.values.max;
      i += this.conf.step || 1
    ) {
      values.push(i);
    }
    return values;
  }

  validateSetValues() {
    const [start, end] = this.conf.set;
    if (this.conf.values.includes(start)) {
      if (!this.conf.range || (end && this.conf.values.includes(end))) {
        return true;
      }
    }
    console.error("Invalid start or end set values...");
    return false;
  }
}
